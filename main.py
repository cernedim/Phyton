# print(5, 8, 6)
# n = 5
# print(n)
# n = None
# print(n)

# a = 5
# b = 4.89
# c = 'hello'

# print(a,b,c)
# print(f"{a} - {b} - {c}")
# print("{} - {} - {}".format(a,b,c))

# print("Введите первое число: ")
# a = int(input())
# b = int(input("Введите второе число: "))
# print(a, '+', b, '=', a + b)

# c = 5.89
# print(c) # 5.89
# n = int(c)
# print(n) # 5
 
# username = input("Введите свое имя: ")
# username = username.lower()
# nameKsy = {'ксюша', 'ксения', 'ксю', 'сюся', 'ksysha', 'ksyha', 'csenia', 'ksenia', 'csyha', 'csysha'}
# if username == "dima":
#     print("Привет хозяин")
# elif username in nameKsy:
#     print("Добро пожаловать, хозяин хозяина.")
# else:
#     print("Привет,", username)

# Сумма всех цифр числа n, например 423 -> 4 + 2 + 3 = 9
# n = 423
# summa = 0
# while n > 0:
#     x = n % 10
#     summa = summa + x
#     n = n // 10
# print(summa)

# n = input("Але, не спи, вводи что то: ")

# import random  # Импортируем модуль random (случайный выбор)

# # Список вариантов приветствий (greetings = "приветствия")
# greetings = [
#     "Привет, дорогой друг!", 
#     "Рад тебя видеть,", 
#     "Добро пожаловать!", 
#     "Приветствую тебя,", 
#     "Здравствуй,"
# ]

# # Список имен, связанных с Ксюшей (name_ksy = "имена_ксю")
# name_ksy = {
#     'ксюша', 'ксения', 'ксю', 'сюся',
#     'ksysha', 'ksyha', 'csenia', 'ksenia', 'csyha', 'csysha'
# }

# # Функция для проверки, есть ли в строке буквы (has_letters = "содержит_буквы")
# def has_letters(input_string):  # input_string = "введенная_строка"
#     return any(char.isalpha() for char in input_string)  # Проверяем, есть ли хотя бы одна буква

# # Функция для получения имени от пользователя (get_valid_username = "получить_корректное_имя_пользователя")
# def get_valid_username():
#     while True:  # Бесконечный цикл, пока пользователь не введет корректное имя
#         username = input("Введите свое имя: ").strip()  # Запрашиваем имя и убираем пробелы (username = "имя_пользователя")
#         if username:  # Проверяем, что пользователь что-то ввел
#             if has_letters(username):  # Проверяем, есть ли в имени хотя бы одна буква
#                 return username.lower().capitalize()  # Приводим имя к нижнему регистру, потом первая буква — заглавная
#             else:
#                 print("Имя должно содержать хотя бы одну букву. Пожалуйста, введите корректное имя.")
#         else:
#             print("Вы ничего не ввели. Пожалуйста, введите свое имя.")  # Просим ввести имя снова

# # Функция для приветствия пользователя (greet_user = "поприветствовать_пользователя")
# def greet_user():
#     username = get_valid_username()  # Получаем корректное имя (username = "имя_пользователя")
    
#     # Проверяем имя и выводим соответствующее сообщение
#     if username.lower() in {"dima", "дима"}:  # Проверяем, соответствует ли имя "Дима"
#         print("Привет, хозяин!")
#     elif username.lower() in name_ksy:  # Проверяем, есть ли имя в списке Ксю (name_ksy = "имена_ксю")
#         print("Добро пожаловать, хозяин хозяина.")
#     else:
#         print(f"{random.choice(greetings)} {username}!")  # Случайное приветствие и корректное имя

# # Запускаем программу
# greet_user()

# def sum_numbers(n):
#     summa = 0
#     n = int(n)
#     for i in range(1, n+1):
#         summa += i
#     return summa
# print(sum_numbers())


# # Способ 1: Рекурсия с мемоизацией (Вычесление чисел Фибоначчи)
# # 1. Использование мемоизации (запоминания): Хранить уже вычисленные значения в памяти, чтобы не вычислять их повторно.
# # • Рекурсия с мемоизацией подходит, если вы предпочитаете рекурсивный стиль и хотите сохранить простоту кода, при этом улучшив производительность.
# def fib(n, memo={}):
#     if n in memo:
#         return memo[n]  # Если значение уже вычислено, возвращаем его из словаря
#     if n in [1, 2]:
#         memo[n] = 1  # Базовые случаи: первые два числа равны 1
#     else:
#         memo[n] = fib(n-1, memo) + fib(n-2, memo)  # Рекурсивный вызов с сохранением результата
#     return memo[n]  # Возвращаем сохраненное значение

# Способ 2: Итеративная функция
# 2. Итеративный подход: Использовать цикл вместо рекурсии для последовательного вычисления чисел Фибоначчи.
# • Итеративный метод обычно быстрее и использует меньше памяти, так как избегает накладных расходов рекурсии.
# def fib(n):
#     if n in [1, 2]:
#         return 1  # Базовые случаи
#     a, b = 1, 1  # Инициализируем первые два числа
#     for _ in range(2, n):
#         a, b = b, a + b  # Последовательно вычисляем следующие числа
#     return b  # Возвращаем n-е число

# # print('\x1b[H\x1b[2J', end='') # Команда для очистки терминала

# list_1 = []
# for i in range(1, 9):
#     list_1.append(fib(i))
# print('\x1b[H\x1b[2J', end='')
# print(list_1)

# def sum_str(*args):
#     res = ''
#     for i in args:
#         res += i
#     return res

# print(sum_str('w', 'w', 'i'))

# def sum_str(*args):
#     return ''.join(map(str, args))  # Преобразуем все аргументы в строки и объединяем их

# print(sum_str('w', 'w', 'i'))  # Результат: 'wwi'
# print(sum_str(1, 2, 3))        # Результат: '123'
# print(sum_str('a', 1, 'b', 2)) # Результат: 'a1b2'


# def sum_str(*args):
#     res = ''
#     for i in args:
#         res += str(i)  # Преобразуем каждый аргумент в строку
#     return res

# print(sum_str('w', 'w', 'i'))  # Результат: 'wwi'
# print(sum_str(1, 2, 3))        # Результат: '123'
# print(sum_str('a', 1, 'b', 2)) # Результат: 'a1b2'
