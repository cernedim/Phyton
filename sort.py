# алгоритмы сотритровки

# def Speed_sort(array):
#     if len(array) <= 1:
#         return array
#     else:
#         pived = array[0]
#     less = [i for i in array[1:] if i <= pived]
#     greeter = [i for i in array[1:] if i > pived]
#     return Speed_sort(less) + [pived] + Speed_sort(greeter)

# print(Speed_sort([12,4,65,7,8,45,9]))

# #111111111111111111111111
# import random

# def Speed_sort(array):
#     # Если длина массива меньше или равна 1, он уже отсортирован.
#     if len(array) <= 1:
#         return array
#     else:
#         # Выбираем случайный элемент массива в качестве опорного.
#         pivot_index = random.randint(0, len(array) - 1)
#         pivot = array[pivot_index]
        
#         # Разбиваем массив на элементы меньше/равные и больше опорного.
#         less = [i for i in array if i < pivot]
#         equal = [i for i in array if i == pivot]
#         greater = [i for i in array if i > pivot]
        
#         # Рекурсивно сортируем и объединяем результаты.
#         return Speed_sort(less) + equal + Speed_sort(greater)

# # Пример использования функции Speed_sort
# print(Speed_sort([12, 4, 65, 7, 8, 45, 9]))

# # Обновленные детали:
# # 	1.	Случайный выбор опорного элемента:
# # 	•	pivot_index выбирается случайным образом с помощью random.randint.
# # 	•	Случайный выбор предотвращает худший случай (например, если массив уже отсортирован).
# # 	2.	Три подмассива:
# # 	•	less: элементы, меньшие опорного.
# # 	•	equal: элементы, равные опорному.
# # 	•	greater: элементы, большие опорного.
# # 	3.	Объединение:
# # 	•	Объединяем отсортированные части: less, equal и greater.
# # Эта модификация делает алгоритм более универсальным и устойчивым к неблагоприятным входным данным.
# #11111111111111111111111111111111


# # Определяем функцию для сортировки методом слияния
# def merge_sort(nums):
#     # Проверяем, если длина массива больше 1
#     if len(nums) > 1:
#         # Находим середину массива
#         mid = len(nums) // 2

#         # Делим массив на две части: левую и правую
#         left = nums[:mid]  # Все элементы от начала до середины
#         right = nums[mid:]  # Все элементы от середины до конца

#         # Рекурсивно вызываем merge_sort для левой половины
#         merge_sort(left)
#         # Рекурсивно вызываем merge_sort для правой половины
#         merge_sort(right)

#         # Инициализируем индексы для слияния массивов
#         i = j = k = 0  # i - индекс левой части, j - индекс правой части, k - индекс итогового массива

#         # Пока есть элементы в обеих частях
#         while i < len(left) and j < len(right):
#             # Сравниваем текущие элементы из левой и правой частей
#             if left[i] < right[j]:  # Если элемент слева меньше
#                 nums[k] = left[i]  # Добавляем его в результирующий массив
#                 i += 1  # Переходим к следующему элементу в левой части
#             else:  # Если элемент справа меньше или равен
#                 nums[k] = right[j]  # Добавляем его в результирующий массив
#                 j += 1  # Переходим к следующему элементу в правой части
#             k += 1  # Переходим к следующей позиции в результирующем массиве

#         # Если остались элементы в левой части, добавляем их
#         while i < len(left):
#             nums[k] = left[i]
#             i += 1
#             k += 1

#         # Если остались элементы в правой части, добавляем их
#         while j < len(right):
#             nums[k] = right[j]
#             j += 1
#             k += 1

# # Создаем массив чисел для сортировки
# list_1 = [1, 2, 3, 44, 6, 7, 8, 9, 0, 93, 876, 54, 3, 45, 67, 654, 5]

# # Вызываем функцию сортировки для массива
# merge_sort(list_1)

# # Выводим отсортированный массив
# print(list_1)

# #1. Рекурсия неявно изменяет массив nums. Можно сделать функцию более понятной, возвращая новый отсортированный список вместо модификации:
# # Эта функция реализует алгоритм сортировки слиянием.
# # Сортировка слиянием — это способ отсортировать список, разделяя его на части и объединяя их в правильном порядке.
# def merge_sort(nums):
#     # Если в списке 1 или меньше элементов, он уже отсортирован. Просто возвращаем его.
#     if len(nums) <= 1:
#         return nums

#     # Находим середину списка, чтобы разделить его на две части.
#     mid = len(nums) // 2

#     # Рекурсивно сортируем левую половину списка.
#     left = merge_sort(nums[:mid])

#     # Рекурсивно сортируем правую половину списка.
#     right = merge_sort(nums[mid:])

#     # Объединяем две отсортированные половины в один отсортированный список.
#     return merge(left, right)

# # Эта функция объединяет два отсортированных списка в один отсортированный.
# def merge(left, right):
#     # Создаем пустой список для хранения результата объединения.
#     result = []

#     # Заводим указатели для левого и правого списков.
#     i = j = 0

#     # Продолжаем, пока не сравним все элементы из одного из списков.
#     while i < len(left) and j < len(right):
#         # Сравниваем текущие элементы левого и правого списков.
#         if left[i] < right[j]:
#             # Если элемент из левого списка меньше, добавляем его в результат.
#             result.append(left[i])
#             i += 1  # Перемещаем указатель в левом списке вперед.
#         else:
#             # Иначе добавляем текущий элемент из правого списка.
#             result.append(right[j])
#             j += 1  # Перемещаем указатель в правом списке вперед.

#     # Если в левом списке остались элементы, добавляем их в результат.
#     result.extend(left[i:])

#     # Если в правом списке остались элементы, добавляем их в результат.
#     result.extend(right[j:])

#     # Возвращаем объединенный и отсортированный список.
#     return result

def merge_sort(nums):
    # Базовый случай: если в списке 1 или меньше элементов, он уже отсортирован
    if len(nums) <= 1:
        return nums

    # Разделяем список на две половины
    mid = len(nums) // 2
    left = merge_sort(nums[:mid])  # Рекурсивная сортировка левой половины
    right = merge_sort(nums[mid:])  # Рекурсивная сортировка правой половины

    # Возвращаем объединенный и отсортированный список
    return merge(left, right)

def merge(left, right):
    result = []  # Список для результата слияния
    i = j = 0  # Указатели для левого и правого списков

    # Пока есть элементы в обоих списках, сравниваем их
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])  # Добавляем меньший элемент из левого списка
            i += 1  # Сдвигаем указатель в левом списке
        else:
            result.append(right[j])  # Добавляем меньший элемент из правого списка
            j += 1  # Сдвигаем указатель в правом списке

    # Добавляем оставшиеся элементы из левого списка (если есть)
    result.extend(left[i:])

    # Добавляем оставшиеся элементы из правого списка (если есть)
    result.extend(right[j:])

    return result  # Возвращаем результат слияния

list_1 = [1, 2, 3, 44, 6, 7, 8, 9, 0, 93, 876, 54, 3, 45, 67, 654, 5]
print(merge_sort(list_1))