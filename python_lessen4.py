def Clear():
    print('\x1b[H\x1b[2J', end='')

# def f(x):
#     return x*x

# a = f
# Clear()
# print(a(5))
# print(f(5))

# def calk1(a, b):
#     return a+b

# def calk2(a, b):
#     return a*b

# def math(op, x, y):
#     print(op(x, y))


# Clear(),math(calk2, 3, 34)

#______________________________________________________________________________________________________________________
#____________________________________________________ЛЯМБДА ФУНКЦИИ____________________________________________________
#______________________________________________________________________________________________________________________

# calk1 = lambda a, b: a+b

# def math(op, x, y):
#     print(op(x, y))

# Clear(),math(calk1, 3, 34)

# def even_num(arr):
#     even = []  # Создаем пустой список для хранения четных чисел
#     for num in arr:  # Перебираем значения массива
#         if num % 2 == 0:  # Проверяем, является ли число четным
#             even.append(num)  # Добавляем четное число в список
#     return even  # Возвращаем список четных чисел

#___________________________________________________ЗАДАЧА____________________________________________________

# import random

# def even_sum(arr):
#     even =[]
#     for num in arr:
#         if num % 2 == 0:
#             even.append((num, num**2))
#     return even

# a = random.sample(range(1, 101), 10)
# print(Clear(), even_sum(a))

#_______________________________________________РЕШЕНИЕ С КОМЕНТАРИЯМИ________________________________________

# import random  # Импортируем модуль random для работы с генерацией случайных чисел.

# def even_sum(arr):
#     # Определяем функцию even_sum, которая ищет четные числа и вычисляет их квадраты.
#     even = []  # Создаем пустой список для хранения четных чисел и их квадратов.

#     for num in arr:  # Перебираем каждое число из переданного списка arr.
#         if num % 2 == 0:  # Проверяем, является ли число четным (делится на 2 без остатка).
#             even.append((num, num**2))  # Добавляем в список кортеж: (число, квадрат числа).
#     return even  # Возвращаем список с четными числами и их квадратами.

# # Генерируем случайный список из 10 уникальных чисел от 1 до 100.
# a = random.sample(range(1, 101), 10)

# # Печатаем очищенный экран, затем исходный список a и результат работы функции even_sum(a).
# print(Clear(), even_sum(a))

#_______________________________________________________________________________________________________________________
#______________________________________________________ФУнкция MAP______________________________________________________
#_______________________________________________________________________________________________________________________

# list_1 = [x for x in range(1, 21)]
# print(Clear(), list_1)

# list_1 = list(map(lambda x: x + 10, list_1))
# print(list_1)
 
#_________________________________________________________________________________________________________________________

# Функция map() в Python — это встроенная функция, которая применяется для выполнения одной и той же операции над каждым элементом итерируемого объекта
# (например, списка, кортежа или множества) и возвращает новый итератор с результатами.

# map(function, iterable)

#___________________Параметры_________________

# 	1.	function: Функция, которую вы хотите применить к каждому элементу итерируемого объекта.
# 	2.	iterable: Последовательность (например, список, кортеж или строка), элементы которой будут обработаны функцией.

#_________________Как это работает_______________

# 	•	map() применяет указанную функцию к каждому элементу в последовательности (или нескольких последовательностях, если их несколько).
# 	•	Возвращает итератор, который можно преобразовать в список, кортеж или другую коллекцию.

#_________________Основные применения_________________

# 	1.	Обработка элементов в коллекции, например:
# 	•	Преобразование всех чисел в список к квадратам.
# 	•	Приведение всех строк к верхнему регистру.
# 	•	Фильтрация данных (в паре с другими функциями).
# 	2.	Удобен для сокращения кода вместо использования циклов.

#_________________Примеры использования_________________

# 1. Применение функции к каждому элементу

# Возведение каждого числа в квадрат:

# numbers = [1, 2, 3, 4, 5]
# squared = map(lambda x: x**2, numbers)  # Применяем лямбда-функцию к каждому числу
# print(list(squared))  # [1, 4, 9, 16, 25]

# 2. Преобразование текста

# Приведение всех строк к верхнему регистру:

# words = ['hello', 'world', 'python']
# uppercase_words = map(str.upper, words)  # Применяем встроенную функцию str.upper
# print(list(uppercase_words))  # ['HELLO', 'WORLD', 'PYTHON']

# 3. Использование с несколькими списками

# Сложение элементов двух списков:

# list1 = [1, 2, 3]
# list2 = [4, 5, 6]
# summed = map(lambda x, y: x + y, list1, list2)  # Применяем лямбда-функцию к элементам двух списков
# print(list(summed))  # [5, 7, 9]

#_________________Преимущества_________________

# 	1.	Код становится компактнее и читаемее по сравнению с использованием циклов.
# 	2.	Работает с любыми итерируемыми объектами (списки, кортежи, множества, словари и т. д.).
# 	3.	Поддерживает использование пользовательских и встроенных функций.

#_________________Особенности_________________

# 	•	map() возвращает объект-итератор. Чтобы получить данные, его нужно преобразовать в список, кортеж или другую структуру данных.
# 	•	Если передается несколько итерируемых объектов, они должны быть одинаковой длины. Иначе обработка завершится, когда самый короткий из них закончится.

#_________________Когда использовать map()?_________________

# 	•	Если нужно применить одну операцию ко всем элементам списка или другой коллекции.
# 	•	Когда требуется улучшить читаемость и компактность кода.
# 	•	Если важна эффективность памяти (итератор map обрабатывает элементы “на лету”, не создавая дополнительных копий данных).

#_________________________________________________________________________________________________________________________
#__________________________________________________________.split_________________________________________________________
#_________________________________________________________________________________________________________________________

# .split - Преобразует строки ''  в списки [].

#________________________________________________________________________________________________________________________

# romaska = '79 0 790 89 08'

# romaska = list(map(int, romaska.split()))
# print(Clear(), romaska) # [79, 0, 790, 89, 08]
#__________________________________________________________
# romaska = '79 0 790 89 08'
# Это строка, содержащая числа, разделенные пробелами.

# romaska = list(map(int, romaska.split()))
# 1. `romaska.split()` — разбивает строку `romaska` на отдельные элементы по пробелам. 
#    Например, '79 0 790 89 08' превратится в список строк: ['79', '0', '790', '89', '08'].
# 2. `map(int, ...)` — преобразует каждую строку из списка в целое число (например, '79' становится 79).
# 3. `list(...)` — превращает результат работы `map()` в список чисел: [79, 0, 790, 89, 8].

# print(Clear(), romaska)
# 1. `Clear()` — функция, которая очищает экран консоли (в данном коде она должна быть определена заранее).
# 2. `romaska` — выводим список чисел, который получился после преобразования.
#_________________________________________________________________________________________________________________________ 

# numbers = [1, 2, 3, 4, 5, 6]

# # Используем лямбда-функцию вместо определения отдельной функции
# even_numbers = filter(lambda x: x % 2 == 0, numbers) # проверка на четность

# print(list(even_numbers))  # Результат: [2, 4, 6]

#__________________________________________________________________________________________________________________________
#_________________________________________________________Функция ZIP______________________________________________________
#__________________________________________________________________________________________________________________________

# Функция zip() в Python используется для “сшивания” последовательностей (например, списков, кортежей, строк и т.д.)
# в один итератор, где каждый элемент является кортежем, содержащим соответствующие элементы из входных последовательностей.

#__________________________Как работает zip()____________________________

#________________________1.	Синтаксис:

# zip(iterable1, iterable2, ..., iterableN)

# •	Принимает произвольное количество итерируемых объектов (списки, строки, кортежи, словари, и т.д.).
# •	Возвращает итератор, который генерирует кортежи из соответствующих элементов входных последовательностей.
# •	Если входные последовательности имеют разную длину, результат будет ограничен длиной самой короткой последовательности.

#________________________2.	Пример использования:

# a = [1, 2, 3]
# b = ['a', 'b', 'c']
# zipped = zip(a, b)
# print(list(zipped))  # [(1, 'a'), (2, 'b'), (3, 'c')]

#________________________3.	Если одна последовательность короче другой:

# a = [1, 2]
# b = ['x', 'y', 'z']
# print(list(zip(a, b)))  # [(1, 'x'), (2, 'y')]

#__________________________Где применяется zip()____________________________

#__________________________1.Создание пар элементов из двух списков:

# Например, при сопоставлении ключей и значений:
# keys = ['name', 'age', 'city']
# values = ['Alice', 30, 'NY']
# dictionary = dict(zip(keys, values))
# print(dictionary)  # {'name': 'Alice', 'age': 30, 'city': 'NY'}

#__________________________2.Объединение итерируемых объектов:

# Используется для обработки двух и более списков одновременно:
# names = ['John', 'Jane', 'Doe']
# scores = [85, 92, 78]
# for name, score in zip(names, scores):
#     print(f'{name}: {score}')

#__________________________3.Транспонирование матриц:

# Используя zip() с распаковкой
# matrix = [
#     [1, 2, 3],
#     [4, 5, 6],
#     [7, 8, 9]
# ]
# transposed = list(zip(*matrix))
# print(transposed)  # [(1, 4, 7), (2, 5, 8), (3, 6, 9)]

#__________________________4.Сравнение двух списков:

# a = [10, 20, 30]
# b = [10, 25, 30]
# comparison = [x == y for x, y in zip(a, b)]
# print(comparison)  # [True, False, True]

#__________________________5.Слияние данных:

#Можно использовать для объединения строк из разных файлов или списков.

#__________________________Важные моменты____________________________

#__________________________• Итератор:

# Результат функции zip() — это итератор, а не список.
# Поэтому для работы с данными его часто приводят к list или другим типам, например:

# list(zip([1, 2], [3, 4]))

#__________________________• Обратная операция:

# zip(*zipped_object) позволяет “развернуть” сшитые данные обратно:

# zipped = zip([1, 2, 3], ['a', 'b', 'c'])
# a, b = zip(*zipped)
# print(a, b)  # (1, 2, 3) ('a', 'b', 'c')

#____________________________________________________________________________________________________________________________________________
#__________________________________________________________Функция enumerate()_______________________________________________________________ 
#____________________________________________________________________________________________________________________________________________

# В Python используется для добавления индексов к элементам итерируемого объекта
# (например, списка, строки, кортежа). Она возвращает итератор, где каждый элемент — это кортеж,
# состоящий из индекса и значения из исходной последовательности.

#__________________________1. Синтаксис:

# enumerate(iterable, start=0)

# •	iterable — любой итерируемый объект (список, строка, кортеж, и т.д.).
# •	start (по умолчанию 0) — начальное значение индекса.

#__________________________2. Пример использования:

# items = ['a', 'b', 'c']
# for index, value in enumerate(items):
#     print(index, value)

# Вывод:
# 0 a
# 1 b
# 2 c

#__________________________3. С указанием стартового индекса:

# items = ['x', 'y', 'z']
# for index, value in enumerate(items, start=1):
#     print(index, value)

# Вывод:
# 1 x
# 2 y
# 3 z

#__________________________Где применяется enumerate()____________________________

#__________________________1. Для доступа к индексам в цикле:

# Если вам нужно одновременно работать с индексами 
# и значениями элементов последовательности, enumerate() — идеальный инструмент:

# colors = ['red', 'green', 'blue']
# for idx, color in enumerate(colors):
#     print(f'Цвет {idx}: {color}')

#__________________________2. Изменение элементов с учетом индекса:

# Например, вы хотите модифицировать элементы списка, используя их индексы:

# numbers = [10, 20, 30, 40]
# for idx, num in enumerate(numbers):
#     numbers[idx] = num * 2
# print(numbers)  # [20, 40, 60, 80]

#__________________________3. Создание словарей из списка с индексами:

# Использование в сочетании с генераторами словарей:

# names = ['Alice', 'Bob', 'Charlie']
# index_to_name = {index: name for index, name in enumerate(names)}
# print(index_to_name)  # {0: 'Alice', 1: 'Bob', 2: 'Charlie'}

#__________________________4. Работа с вложенными структурами:

# Можно применять для обработки вложенных списков:

# data = [['a', 'b'], ['c', 'd'], ['e', 'f']]
# for i, pair in enumerate(data):
#     print(f'Пара {i}: {pair}')

#__________________________5. Отслеживание итерации в длинных циклах:

# Например, если вы хотите остановить цикл на определенном этапе, используя индекс:

# for i, value in enumerate(range(100), start=1):
#     print(value)
#     if i == 10:  # Прерываем на 10-м элементе
#         break

#____________________________________________________________________________________________________________________________________________